"use strict";
/* IMPORT */
Object.defineProperty(exports, "__esModule", { value: true });
var string_indexes_1 = require("string-indexes");
var types_1 = require("./types");
var SELECTOR = types_1.TOKEN_TYPE.SELECTOR, BODY_START = types_1.TOKEN_TYPE.BODY_START, BODY_END = types_1.TOKEN_TYPE.BODY_END;
/* MERGE TOKENS */
function mergeTokensSorted(t1, t2) {
    var length = t1.length + t2.length, i = t1.length - 1, j = t2.length - 1;
    var merged = new Array(length);
    while (length > 0) {
        merged[--length] = (j < 0 || (i >= 0 && t1[i].index > t2[j].index)) ? t1[i--] : t2[j--];
    }
    return merged;
}
function mergeTokensSortedEvenOdd(t1, t2) {
    var length = t1.length, merged = new Array(length * 2);
    for (var i = 0, j = 0; i < length; i++, j += 2) {
        merged[j] = t1[i];
        merged[j + 1] = t2[i];
    }
    return merged;
}
/* FIND SELECTOR START INDEX */
function findSelectorStartIndex(tokens, tokenIndexStart, limit) {
    if (tokenIndexStart === void 0) { tokenIndexStart = 0; }
    var lastIndex = 0, lastTokenIndex = tokenIndexStart;
    for (var i = tokenIndexStart, l = tokens.length; i < l; i++) {
        var token = tokens[i], index = token.index;
        if (index >= limit)
            break;
        lastIndex = (token.type === BODY_START) ? index : index + 1;
        lastTokenIndex = i + 1;
    }
    return [lastIndex, lastTokenIndex];
}
/* TOKENIZER */
function tokenizer(css) {
    /* VARIABLES */
    var startIndexes = string_indexes_1.default(css, '{'), endIndexes = string_indexes_1.default(css, '}'), selectorTokens = new Array(startIndexes.length), startTokens = new Array(startIndexes.length), endTokens = new Array(endIndexes.length);
    var selectorIndex = 0, startIndex = 0, endIndex = 0;
    /* BODY_START */
    for (var i = 0, l = startIndexes.length; i < l; i++) {
        startTokens[startIndex++] = {
            type: BODY_START,
            index: startIndexes[i] + 1 // Start index
        };
    }
    /* BODY_END */
    for (var i = 0, l = endIndexes.length; i < l; i++) {
        endTokens[endIndex++] = {
            type: BODY_END,
            index: endIndexes[i] // End index
        };
    }
    /* SELECTOR */
    var prevStartTokenIndex = 0, prevEndTokenIndex = 0;
    for (var i = 0, l = startIndexes.length; i < l; i++) {
        var indexEnd = startIndexes[i], findStartData = findSelectorStartIndex(startTokens, prevStartTokenIndex, indexEnd), findEndData = findSelectorStartIndex(endTokens, prevEndTokenIndex, indexEnd);
        prevStartTokenIndex = findStartData[1];
        prevEndTokenIndex = findEndData[1];
        var index = (findStartData[0] >= findEndData[0]) ? findStartData[0] : findEndData[0], selector = css.slice(index, indexEnd), semicolonIndex = index + selector.lastIndexOf(';', indexEnd) + 1;
        if (semicolonIndex > index) {
            index = semicolonIndex;
            selector = css.slice(index, indexEnd);
        }
        selectorTokens[selectorIndex++] = {
            type: SELECTOR,
            index: index,
            indexEnd: indexEnd,
            selector: selector
        };
    }
    /* RETURN */
    return mergeTokensSorted(mergeTokensSortedEvenOdd(selectorTokens, startTokens), endTokens);
}
/* EXPORT */
exports.default = tokenizer;
